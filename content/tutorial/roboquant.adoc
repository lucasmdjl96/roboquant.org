= Roboquant
:source-highlighter: rouge
:icons: font
:sourcefile: ../../samples/roboquant.kt
:jbake-date: 2020-10-01

== Create
The `Roboquant` class (org.roboquant.Roboquant) is the engine of the platform, not to be confused with _roboquant_ (all small letters) which is the name of the platform itself. An instance of the `Roboquant` class orchestrates the interaction between all the components and performs the actual runs.

You are only required to provide a strategy when creating a new instance of _Roboquant_. So the bare minimum to get a working instance would look something like this:

[source, kotlin, indent=0]
----
include::{sourcefile}[tag=basic]
----

The following default values will then be used:

* No metrics will be captured at all
* The `SimBroker` will be used as the broker with its default settings
* The `DefaultPolicy` will be the policy used
* The `MemoryLogger` for logging the metrics (although without any metrics to capture, there is not much to log)

Each of these defaults can be overwritten with a different implementation when you instantiate a `Roboquant`, as the following code snippet shows:

[source, kotlin, indent=0]
----
include::{sourcefile}[tag=complete]
----

== Run
After you have created an instance of the `Roboquant` class and have a xref:./feed.adoc[data feed], you can start the run.

NOTE: The same `run` method is used for all the different stages, from back testing to live trading. See also xref:../background/four_stages.adoc[the 4 stages] for more details about these stages.

In the most simple form, you only need to provide a feed as the argument. In this case, all the events available in the feed will be used in the run.

[source, kotlin, indent=0]
----
include::{sourcefile}[tag=run]
----

If you provide a live feed, it would potentially run forever. However, you can restrict the run to a certain timeframe, again you can use this for a historical feed and a live feed alike.

[source, kotlin, indent=0]
----
include::{sourcefile}[tag=run2]
----

You can invoke a run multiple times, for example with different timeframes. The following code shows how to use this to perform a walk-forward back test of two-year periods:

[source, kotlin, indent=0]
----
include::{sourcefile}[tag=run3]
----

== Running in Parallel
If you want to run many back-test, you can run them in parallel and leverage all the cores on your computer to expedite the process. _Roboquant_ scales almost linear with the number of available cores, and it only requires a few extra lines of code.

The following example shows how to run a walk forward in parallel. By reusing the same logger instance, all results will be stored in a single instance and can be easily compared afterwards.

[source, kotlin, indent=0]
----
include::{sourcefile}[tag=runParallel]
----

