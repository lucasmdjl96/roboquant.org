= Policy
:source-highlighter: rouge
:icons: font
:sourcefile: ../../../samples/policy.kt

A policy is responsible for generating the orders that will be placed at a broker. The most common use-case is that a policy does this based on the signals it receives from a strategy.

A good policy is key in making your solution as robust as possible. Key things to consider when implementing a new policy:

* What is a good allocation strategy
* What order types to use
* How to handle new orders when there are still open orders for the same asset
* How to limit the maximum number of orders send to a broker (circuit breaker)
* How to deal with conflicting signals from a strategy
* How to handle yo-yo signals (buy-sell-buy-sell) in a short timeframe
* How to manage risk and exposure
* How to ensure there is still enough balance left to place an order

NOTE: If there is one thing that prevents people from actually going live with a strategy, it is that there is not a robust policy in place that handles all the possible edge-cases.


== Out-of-the-box policies

=== DefaultPolicy
As the name already suggests, this is the default policy that will be used if no other policy is specified.

== Implementing your own policies
In case none of the out-of-the-box policies will do, you can always implement your own policy. You only have to implement a single method:

[source, kotlin]
----
include::{sourcefile}[tag=basic]
----

So a very naive implementation could look something like this:

[source, kotlin]
----
include::{sourcefile}[tag=naive]
----

Or using the more concise Kotlin way of doing things:
[source, kotlin]
----
include::{sourcefile}[tag=naive2]
----


== Advanced policies
A policy can be used to transform signals into orders. But it can also be used for more advanced strategies that directly translates events into orders, thus skipping the signals all together.

