= Welcome
:icons: font
:source-highlighter: rouge
:jbake-date: 2020-01-31

Welcome to the roboquant documentation. The roboquant platform has 4 main goals:

. Fast, so you can validate ideas as quickly as possible
. Flexible, so you can convert any idea into a strategy
. Easy, so you don't spend time with learning things that don't add value
. Free, so anyone can improve the platform


TIP: If you like to learn more by being hands-on, there are several ready to use tutorials in Jupyter Notebook format that you can try out. To find out more, go to: https://github.com/neurallayer/roboquant-notebook/tree/main[Tutorial Notebooks]


== Data Flow
Perhaps the most important part of using roboquant is to understand the main flow of data and the responsibility each component has in this flow.

The following diagram shows the main components of the platform and the type of data they consume and produce.

image::main_flow.png[]

NOTE: it is an instance of the Roboquant class that orchestrates the data flow between the components in order to allow for low coupling and easy swapping out of components. So components don't directly call each other.

The role and responsibilities of each of the components:

* Roboquant
+
The engine of the platform that performs the actual run and orchestrate the interaction between the components. The engine supports all xref:four_stages.adoc[four stages] of developing a strategy with minimal change to your code. This is also the only component that is not designed to be swapped out for a custom one.

*  Feed
+
Provides the data needed for testing and trading in the form of events. A feed can represent both historic and live data.

* Strategy
+
Receives events from the feed and generates signals. A signal consist of a rating for a certain asset, like a BUY rating for Tesla. So a strategy doesn't create orders, that is the responsibility of a policy.

* Policy
+
Receives the signals and creates orders.

* Broker
+
Received the orders generated by the policy and process them. Any open orders will also be processed until they are closed. After this step, it will return an updated account that reflects the order and trade status.

* Metric
+
Receives the last state of the account and calculates various metrics that are of interest to determine the progress and results of the run.

* Metrics Logger
+
Stores and/or log the metric values

== Running a strategy
Developing a strategy and validate it during a back-test is a straight forward process.

[source, kotlin,  subs="attributes,verbatim"]
----
class MyStrategy : Strategy { // <1>
    override fun generate(event: Event): List<Signal> {
        // your code goes here
    }
}

val strategy = MyStrategy() // <2>
val metric = AccountSummary() //<3>
val roboquant = Roboquant(strategy, metric) //<4>

val feed = CSVFeed("./data/us") //<5>
roboquant.run(feed) //<6>
----
<1> Develop a new strategy based on some idea you have. This can be done either from scratch or by assembling existing building blocks. In many cases, this is the only real software development required.
<2> Create an instance of your strategy
<3> Instantiate the metrics you want to use to evaluate the performance of your strategy.
<4> Create an instance of Roboquant (the engine) with the strategy and metric(s) as parameters.
<5> Pick the data feed you want to use to validate your strategy.
<6> Run the back test using the data feed you just created.

The platform is very flexible and provides way more options than the above example shows. You can easily extend almost any part of the system if the default included behavior doesn't work for you.