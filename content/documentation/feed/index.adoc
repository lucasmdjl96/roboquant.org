= Feed
:source-highlighter: rouge
:sourcefile: ../../../samples/feed.kt
:jbake-date: 2020-01-31

A feed is responsible for delivering the data that is required to test and run strategies. There are no restrictions on the type of data that a Feed can emit. It can be a simple as a stock prices or as complex as a satellite image.

A Feed can be used to deliver historic and live data. A feed wraps its information in an event and put that event on a EventChannel. This is all done asynchronously from rest of the trading logic. And although an `EventChannel` is used to deliver the events, this channel is normally only directly accessed by the `Roboquant` instance. A strategy will be passed just the plain Event object.

To read more why roboquant has selected this event-driven approach, read this xref:../introduction/events.adoc[introduction on event-driven software].

== Event
An `Event` instance contains all the data that happens at a certain point in time. It contains the following two attributes

. The `time` attribute when the information within the event became available.
. The list of all the `actions` at that time

Events are always delivered in chronological order.

=== Time
The time in an event is of the type Instant. It is very important that the time in the event reflects when the actions in that same event became available, not when they happened. Typically, there is some delay between when something occurred and when it is published.

For example when you want to use unemployment numbers as part of your feed, you should use the time when they are published, and you have access to them, not the last day of the period they cover. Otherwise, your strategy is looking into the future during back testing and can make decisions based on information it will never have in live trading.

=== Action
Action is an abstraction for any type of information that can be made available in an event.

An action can range from price actions, like price-bars and order-book snapshots, to social media content or even satellite images. There is no commonality between actions, and you can add any type of actions you like to the platform. The only requirements is that they implement the empty interface `Action`

It is up to the strategy to filter for the action types it is interested in, for example:

[source, kotlin, indent=0]
----
include::{sourcefile}[tag=event]
----

There are however a few helper methods in Event to access PriceActions that are of interest of many strategies:

[source, kotlin, indent=0]
----
include::{sourcefile}[tag=priceaction]
----

== Included Feeds
Roboquant includes several `Feed` implementations out of the box:

* CSVFeed that can process CSV files stored somewhere on your local machine. You read more about it xref:csv.adoc[here]
* AvroFeed that can process an Avro file stored somewhere on your local machine. . You read more about them xref:avro.adoc[here]
* RandomWalk that (as the name suggests) generates random price actions for random assets.
* Integration with third party data providers that make their data available through an API. See also the xref:../integration/index.adoc[integration documentation]


== Custom Feeds
If you have a data source that is not yet covered by roboquant, you can implement your own `Feed`. The main method to implement is the `play` method that will put the available events on the channel.

[source, kotlin]
----
interface Feed {

    val timeFrame: TimeFrame
        get() = TimeFrame.FULL

    suspend fun play(channel: EventChannel)
}
----

The following implementation of the `play` method sends out 100 empty events, empty meaning an event without any actions included. In case the EventChannel is full, the `channel.send` method will be blocking.

[source, kotlin, indent=0]
----
include::{sourcefile}[tag=play]
----
